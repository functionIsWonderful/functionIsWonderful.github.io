{"pages":[],"posts":[{"title":"React Hooks的使用","text":"为什么需要Hook? Hook 是 React 16.8 的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。 我们先来思考一下class组件相对于函数式组件有什么优势？比较常见的是下面的优势： 1.class组件可以定义自己的state，用来保存组件自己内部的状态； 函数式组件不可以，因为函数每次调用都会产生新的临时变量； 2.class组件有自己的生命周期，我们可以在对应的生命周期中完成自己的逻辑； 比如在componentDidMount中发送网络请求，并且该生命周期函数只会执行一次； 函数式组件在学习hooks之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求； 3.class组件可以在状态改变时只会重新执行render函数以及我们希望重新调用的生命周期函数componentDidUpdate等； 函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次； 所以，在Hook出现之前，对于上面这些情况我们通常都会编写class组件。 Class组件存在的问题 复杂组件变得难以理解： 我们在最初编写一个class组件时，往往逻辑比较简单，并不会非常复杂。但是随着业务的增多，我们的class组件会变得越来越复杂； 比如componentDidMount中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在componentWillUnmount中移除）； 而对于这样的class实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度； 难以理解的class： 很多人发现学习ES6的class是学习React的一个障碍。 比如在class中，我们必须搞清楚this的指向到底是谁，所以需要花很多的精力去学习this； 组件复用状态很难： 1.为了一些状态的复用我们需要通过高阶组件或render props； 2.redux中connect或者react-router中的withRouter，这些高阶组件设计的目的就是为了状态的复用； 3.类似于Provider、Consumer来共享一些状态，但是多次使用Consumer时，我们的代码就会存在很多嵌套； Hook的出现 Hook的出现，可以解决上面提到的这些问题； 简单总结一下hooks： 1.它可以让我们在不编写class的情况下使用state以及其他的React特性； 2.但是我们可以由此延伸出非常多的用法，来让我们前面所提到的问题得到解决； Hook的使用场景： 1.Hook的出现基本可以代替我们之前所有使用class组件的地方（除了一些非常不常用的场景）； 2.但是如果是一个旧的项目，你并不需要直接将所有的代码重构为Hooks，因为它完全向下兼容，你可以渐进式的来使用它； 3.Hook只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用； 计数器案例对比 我们通过一个计数器案例，来对比一下class组件和函数式组件结合hooks的对比： 123456789101112131415161718192021222324252627282930import React, { PureComponent } from &apos;react&apos;export default class CounterClass extends PureComponent { constructor(props) { super(props); this.state = { counter: 0 } } render() { console.log(&quot;class counter渲染&quot;); return ( &lt;div&gt; &lt;h2&gt;当前计数: {this.state.counter}&lt;/h2&gt; &lt;button onClick={e =&gt; this.increment()}&gt;+1&lt;/button&gt; &lt;button onClick={e =&gt; this.decrement()}&gt;-1&lt;/button&gt; &lt;/div&gt; ) } increment() { this.setState({counter: this.state.counter + 1}) } decrement() { this.setState({counter: this.state.counter - 1}) }} 123456789101112131415161718192021222324import React, { useState } from &apos;react&apos;;export default function CounterHook() { /** * Hook: useState * &gt; 本身是一个函数, 来自react包 * &gt; 参数和返回值 * 1.参数: 作用是给创建出来的状态一个默认值 * 2.返回值: 数组 * * 元素1: 当前state的值 * * 元素2: 设置新的值时,使用的一个函数 */ const arr = useState(0); const state = arr[0]; const setState = arr[1]; return ( &lt;div&gt; &lt;h2&gt;当前计数: {state}&lt;/h2&gt; &lt;button onClick={e =&gt; setState(state + 1)}&gt;+1&lt;/button&gt; &lt;button onClick={e =&gt; setState(state - 1)}&gt;-1&lt;/button&gt; &lt;/div&gt; )} 你会发现上面的代码差异非常大：函数式组件结合hooks让整个代码变得非常简洁，并且再也不用考虑this相关的问题； useState解析 useState来自react，需要从react中导入，它是一个hook； 参数：初始化值，如果不设置为undefined； 返回值：数组，包含两个元素； 元素一：当前状态的值（第一调用为初始化值）； 元素二：设置状态值的函数； 点击button按钮后，会完成两件事情： 调用setCount，设置一个新的值； 组件重新渲染，并且根据新的值返回DOM结构； Hook 就是 JavaScript 函数，这个函数可以帮助你 钩入（hook into） React State以及生命周期等特性； 但是使用它们会有两个额外的规则： 1.只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。 2.只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。 Tip： Hook指的类似于useState、useEffect这样的函数 Hooks是对这类函数的统称； 认识useState useState会帮助我们定义一个 state变量，useState 是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 React 保留。 useState接受唯一一个参数，在第一次组件被调用时使用来作为初始化值。（如果没有传递参数，那么初始化值为undefined） useState是一个数组，我们可以通过数组的解构，来完成赋值会非常方便。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment FAQ：为什么叫 useState 而不叫 createState? “Create” 可能不是很准确，因为 state 只在组件首次渲染的时候被创建。 在下一次重新渲染时，useState 返回给我们当前的 state。 如果每次都创建新的变量，它就不是 “state”了。 这也是 Hook 的名字总是以 use 开头的一个原因。 当然，我们也可以在一个组件中定义多个变量和复杂变量（数组、对象） 认识Effect Hook 目前我们已经通过hook在函数式组件中定义state，那么类似于生命周期这些呢？ Effect Hook 可以让你来完成一些类似于class中生命周期的功能； 事实上，类似于网络请求、手动更新DOM、一些事件的监听，都是React更新DOM的一些副作用（Side Effects）； 所以对于完成这些功能的Hook被称之为 Effect Hook； 案例：页面的title总是显示counter的数字，分别使用class组件和Hook实现： 123456789101112131415161718192021222324252627282930313233343536373839import React, { PureComponent } from &apos;react&apos;export default class ClassCounterTitleChange extends PureComponent { constructor(props) { super(props); this.state = { counter: 0 } } componentDidMount() { // 1.修改DOM document.title = this.state.counter; // 2.订阅事件 console.log(&quot;订阅一些事件&quot;); // 3.网络请求 } componentWillUnmount() { console.log(&quot;取消事件订阅&quot;); } componentDidUpdate() { document.title = this.state.counter; } render() { return ( &lt;div&gt; &lt;h2&gt;当前计数: {this.state.counter}&lt;/h2&gt; &lt;button onClick={e =&gt; this.setState({counter: this.state.counter + 1})}&gt;+1&lt;/button&gt; &lt;/div&gt; ) }} 12345678910111213141516import React, { useState, useEffect } from &apos;react&apos;export default function HookCounterChangeTitle() { const [counter, setCounter] = useState(0); useEffect(() =&gt; { document.title = counter; }) return ( &lt;div&gt; &lt;h2&gt;当前计数: {counter}&lt;/h2&gt; &lt;button onClick={e =&gt; setCounter(counter + 1)}&gt;+1&lt;/button&gt; &lt;/div&gt; )} useEffect的解析： 1.通过useEffect的Hook，可以告诉React需要在渲染后执行某些操作； 2.useEffect要求我们传入一个回调函数，在React执行完更新DOM操作之后，就会回调这个函数； 3.默认情况下，无论是第一次渲染之后，还是每次更新之后，都会执行这个回调函数； 需要清除Effect 在class组件的编写过程中，某些副作用的代码，我们需要在componentWillUnmount中进行清除： 比如我们之前的事件总线或Redux中手动调用subscribe； 都需要在componentWillUnmount有对应的取消订阅； Effect Hook通过什么方式来模拟componentWillUnmount呢？ useEffect传入的回调函数A本身可以有一个返回值，这个返回值是另外一个回调函数B： type EffectCallback = () =&gt; (void | (() =&gt; void | undefined)); 为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数； 如此可以将添加和移除订阅的逻辑放在一起； 它们都属于 effect 的一部分； React 何时清除 effect？ React 会在组件更新和卸载的时候执行清除操作； effect 在每次渲染的时候都会执行； 使用多个Effect 使用Hook的其中一个目的就是解决class中生命周期经常将很多的逻辑放在一起的问题： 比如网络请求、事件监听、手动修改DOM，这些往往都会放在componentDidMount中； 使用Effect Hook，我们可以将它们分离到不同的useEffect中： 1234567891011121314151617181920212223242526272829import React, { useState, useEffect } from &apos;react&apos;export default function MultiEffectHookDemo() { const [count, setCount] = useState(0); const [isLogin, setIsLogin] = useState(true); useEffect(() =&gt; { console.log(&quot;修改DOM&quot;, count); }, [count]); useEffect(() =&gt; { console.log(&quot;订阅事件&quot;); }, []); useEffect(() =&gt; { console.log(&quot;网络请求&quot;); }, []); return ( &lt;div&gt; &lt;h2&gt;MultiEffectHookDemo&lt;/h2&gt; &lt;h2&gt;{count}&lt;/h2&gt; &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt; &lt;h2&gt;{isLogin ? &quot;admin&quot;: &quot;未登录&quot;}&lt;/h2&gt; &lt;button onClick={e =&gt; setIsLogin(!isLogin)}&gt;登录/注销&lt;/button&gt; &lt;/div&gt; )} Hook 允许我们按照代码的用途分离它们， 而不是像生命周期函数那样： React 将按照 effect 声明的顺序依次调用组件中的每一个 effect； Effect性能优化 默认情况下，useEffect的回调函数会在每次渲染时都重新执行，但是这会导致两个问题： 某些代码我们只是希望执行一次即可，类似于componentDidMount和componentWillUnmount中完成的事情；（比如网络请求、订阅和取消订阅); 多次执行也会导致一定的性能问题； 我们如何决定useEffect在什么时候应该执行和什么时候不应该执行呢？ useEffect实际上有两个参数： 参数一：执行的回调函数； 参数二：该useEffect在哪些state发生变化时，才重新执行；（受谁的影响） 案例： 受count影响的Effect； 12345678910111213141516171819202122import React, { useEffect, useState } from &apos;react&apos;export default function EffectHookCancelDemo() { const [count, setCount] = useState(0); useEffect(() =&gt; { console.log(&quot;订阅一些事件&quot;); return () =&gt; { console.log(&quot;取消订阅事件&quot;) } }, []); return ( &lt;div&gt; &lt;h2&gt;EffectHookCancelDemo&lt;/h2&gt; &lt;h2&gt;{count}&lt;/h2&gt; &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt; &lt;/div&gt; )} 如果一个函数我们不希望依赖任何的内容时，也可以传入一个空的数组 []： 那么这里的两个回调函数分别对应的就是componentDidMount和componentWillUnmount生命周期函数了； useContext的使用 在之前的开发中，我们要在组件中使用共享的Context有两种方式： 类组件可以通过 类名.contextType = MyContext方式，在类中获取context； 多个Context或者在函数式组件中通过 MyContext.Consumer 方式共享context； 但是多个Context共享时的方式会存在大量的嵌套： Context Hook允许我们通过Hook来直接获取某个Context的值； 12345678910111213141516import React, { useContext } from &apos;react&apos;;import { UserContext, ThemeContext } from &quot;../App&quot;;export default function ContextHookDemo(props) { const user = useContext(UserContext); const theme = useContext(ThemeContext); console.log(user, theme); return ( &lt;div&gt; &lt;h2&gt;ContextHookDemo&lt;/h2&gt; &lt;/div&gt; )} 注意事项： 当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重新渲染，并使用最新传递给 MyContext provider 的 context value 值。 注：本文内容来自王红元老师react课程的ppt资料，本人仅做整理归纳供学习专用。","link":"/2020-12-%E5%89%8D%E7%AB%AF/React-react-hooks%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Redux的使用","text":"纯函数的维基百科定义： 在程序设计中，若一个函数符合一下条件，那么这个函数被称为纯函数：1.此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。 2.该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。 当然上面的定义会过于的晦涩，所以我简单总结一下：1.确定的输入，一定会产生确定的输出； 2.函数在执行过程中，不能产生副作用； 那么我们来看几个函数是否是纯函数：纯函数分析 案例一： 很明显，下面的函数是一个纯函数； 它的输出是依赖我们的输入内容，并且中间没有产生任何副作用； 123function sum(num1, num2) { return num1 + num2} 案例二： add函数不是一个纯函数； 函数依赖一个外部的变量，变量发生改变时，会影响：确定的输入，产生确定的输出； 能否改进成纯函数呢？ const foo = 5; 即可 12345let foo = 5;function add(num) { return num + foo} React中的纯函数当然纯函数还有很多的变种，但是我们只需要理解它的核心就可以了。 为什么纯函数在函数式编程中非常重要呢？ ​ 1.因为你可以安心的写和安心的用； ​ 2.你在写的时候保证了函数的纯度，只是但是实现自己的业务逻辑即可，不需要关心传入的内容或者依赖其他的外部变量； ​ 3.你在用的时候，你确定你的输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出； React中就要求我们无论是函数还是class声明一个组件，这个组件都必须像纯函数一样，保护它们的props不被修改： https://zh-hans.reactjs.org/docs/components-and-props.html#props-are-read-only 学习redux中，reducer也被要求是一个纯函数。 为什么需要redux JavaScript开发的应用程序，已经变得越来越复杂了：1.JavaScript需要管理的状态越来越多，越来越复杂； 2.这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等，也包括一些UI的状态，比如某些元素是否被选中，是否显示加载动效，当前分页； 管理不断变化的state是非常困难的：1.状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，View页面也有可能会引起状态的变化； 2.当应用程序复杂时，state在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控制和追踪； React是在视图层帮助我们解决了DOM的渲染过程，但是State依然是留给我们自己来管理：1.无论是组件定义自己的state，还是组件之间的通信通过props进行传递；也包括通过Context进行数据之间的共享； 2.React主要负责帮助我们管理视图，state如何维护最终还是我们自己来决定； Redux就是一个帮助我们管理State的容器：Redux是JavaScript的状态容器，提供了可预测的状态管理； Redux除了和React一起使用之外，它也可以和其他界面库一起来使用（比如Vue），并且它非常小（包括依赖在内，只有2kb） Redux的核心理念 - Store Redux的核心理念非常简单。 比如我们有一个朋友列表需要管理：1.如果我们没有定义统一的规范来操作这段数据，那么整个数据的变化就是无法跟踪的； 2.比如页面的某处通过products.push的方式增加了一条数据； 3.比如另一个页面通过products[0].age = 25修改了一条数据； 整个应用程序错综复杂，当出现bug时，很难跟踪到底哪里发生的变化； 1234567const initialState = { friends: [ { name: &quot;Lilei&quot;,age: 18 }, { name: &quot;Hanmeimei&quot;,age: 20 }, { name: &quot;Tom&quot;,age: 35 }, ]}; Redux的核心理念 - action Redux要求我们通过action来更新数据：1.所有数据的变化，必须通过派发（dispatch）action来更新； 2.action是一个普通的JavaScript对象，用来描述这次更新的type和content； 比如下面就是几个更新friends的action：1.强制使用action的好处是可以清晰的知道数据到底发生了什么样的变化，所有的数据变化都是可跟追、可预测的； 2.当然，目前我们的action是固定的对象，真实应用中，我们会通过函数来定义，返回一个action； 123const action1 = { type: &quot;ADD_FRIEND&quot;, info: { name: &quot;lucy&quot;, age: 20 } }const action2 = { type: &quot;INC_AGE&quot;, info: 0 }const action3 = { type: &quot;CHANGE_NAME&quot;, playload: { index: 0, newName: &quot;huahua&quot; } } Redux的核心理念 - reducer 但是如何将state和action联系在一起呢？答案就是reducer 1.reducer是一个纯函数； 2.reducer做的事情就是将传入的state和action结合起来生成一个新的state； 123456789101112131415161718192021222324252627function reducer(state = initialState, action) { switch (action.type) { case &quot;ADD_FRIEND&quot;: return { ...state, friends: [...state.friends, action.info] }; case &quot;INC_AGE&quot;: return { ...state, friends: state.friends.map((item,index) =&gt; { if (index === action.index) { return { ...item, age: item.age + 1} } return item; }) }; case &quot;CHANGE_NAME&quot;: return { ...state, friends: state.friends.map((item,index) =&gt; { if (index === action.index) { return { ...item, name: action.newName} } return item; }) }; default: return state; }} Redux的三大原则 单一数据源1.整个应用程序的state被存储在一颗object tree中，并且这个object tree只存储在一个 store 中： 2.Redux并没有强制让我们不能创建多个Store，但是那样做并不利于数据的维护； 3.单一的数据源可以让整个应用程序的state变得方便维护、追踪、修改； State是只读的1.唯一修改State的方法一定是触发action，不要试图在其他地方通过任何的方式来修改State： 2.这样就确保了View或网络请求都不能直接修改state，它们只能通过action来描述自己想要如何修改state； 3.这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执行，所以不需要担心race condition（竟态）的问题； 使用纯函数来执行修改1.通过reducer将 旧state和 actions联系在一起，并且返回一个新的State： 2.随着应用程序的复杂度增加，我们可以将reducer拆分成多个小的reducers，分别操作不同state tree的一部分； 3.但是所有的reducer都应该是纯函数，不能产生任何的副作用； Redux测试项目搭建 安装redux： 12345npm install redux --save #或 yarn add redux ​ 1.创建一个新的项目文件夹：learn-redux 1234567# 执行初始化操作yarn init# 安装reduxyarn add redux ​ 2.创建src目录，并且创建index.js文件 ​ 3.修改package.json可以执行index.js 12345&quot;scripts&quot;: {&quot;start&quot;: &quot;node src/index.js&quot; } Redux的使用过程 创建一个对象，作为我们要保存的状态： 创建Store来存储这个state1.创建store时必须创建reducer； 2.我们可以通过 store.getState 来获取当前的state 通过action来修改state1.通过dispatch来派发action； 2.通常action中都会有type属性，也可以携带其他的数据； 修改reducer中的处理代码1.记住，reducer是一个纯函数，不需要直接修改state； 可以在派发action之前，监听store的变化： Redux使用流程 知道了redux的基本使用过程，那么我们就更加清晰来认识一下redux在实际开发中的流程： 注：本文内容来自王红元老师react课程的ppt资料，本人仅做整理归纳供学习专用。","link":"/2020-12-%E5%89%8D%E7%AB%AF/React-redux%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"在TypeScript下使用字符串字面量类型和枚举","text":"定义字面量(Literals)：字面量是由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals 在JavaScript中，你可以使用各种字面量。这些字面量是脚本中按字面意思给出的固定的值，而不是变量。（译注：字面量是常量，其值是固定的，而且在程序脚本运行中不可更改，比如false，3.1415，thisIsStringOfHelloworld ，invokedFunction: myFunction(“myArgument”)。 字符串字面量(String literals)：字符串字面量是由双引号（”）对或单引号（’）括起来的零个或多个字符。字符串被限定在同种引号之间；也即，必须是成对单引号或成对双引号A string literal is zero or more characters enclosed in double (&quot;) or single (&apos;) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks). 枚举(enums)：使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript. Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums. 用法字符串字面量：例1：123456789type EventNames = &apos;click&apos; | &apos;scroll&apos; | &apos;mousemove&apos;;function handleEvent(ele: Element, event: EventNames) { // do something}handleEvent(document.getElementById(&apos;hello&apos;), &apos;scroll&apos;); // 没问题handleEvent(document.getElementById(&apos;world&apos;), &apos;dblclick&apos;); // 报错，event 不能为 &apos;dblclick&apos;// index.ts(7,47): error TS2345: Argument of type &apos;&quot;dblclick&quot;&apos; is not assignable to parameter of type &apos;EventNames&apos;. 上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。 注意，字符串字面量类型使用 type 进行定义。 例2：12345678type CardinalDirection = &apos;North&apos; | &apos;East&apos; | &apos;South&apos; | &apos;West&apos;;function move(distance: number, direction: CardinalDirection) { // ...}move(1, &apos;North&apos;); // okmove(1, &apos;Nurth&apos;); // Error 枚举：数字枚举123456enum Direction { Up = 1, Down, Left, Right} 如上，我们定义了一个数字枚举，Up使用初始化为1。其余的成员会从1开始自动增长。换句话说，Direction.Up的值为1，Down为2，Left为3，Right为4。 我们还可以完全不使用初始化器： 123456enum Direction { Up, Down, Left, Right,} 现在，Up的值为0，Down的值为1等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。 使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型： 12345678910enum Response { No = 0, Yes = 1,}function respond(recipient: string, message: Response): void { // ...}respond(&quot;Princess Caroline&quot;, Response.Yes) 数字枚举可以被混入到计算过的和常量成员（如下所示）。简短地说，不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。 换句话说，下面的情况是不被允许的： 1234enum E { A = getSomeValue(), B, // error! &apos;A&apos; is not constant-initialized, so &apos;B&apos; needs an initializer} 字符串枚举字符串枚举的概念很简单，但是有细微的运行时的差别。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 123456enum Direction { Up = &quot;UP&quot;, Down = &quot;DOWN&quot;, Left = &quot;LEFT&quot;, Right = &quot;RIGHT&quot;,} 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的————它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。 参考： MDN Web 文档(中文手册) TypeScript的入门教程(中文手册) 深入理解TypeScript","link":"/2020-12-%E5%89%8D%E7%AB%AF/TypeScript-%E5%9C%A8typescript%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9E%9A%E4%B8%BE/"},{"title":"使用homebrew发生的事情","text":"用homebrew下载uzip,报了以下错误： Calling brew cask install is disabled! Use brew install [–cask] instead. 解决方案：https://github.com/Homebrew/discussions/discussions/340 1$ brew install --cask --appdir=/Applications uzip","link":"/2021-1-mac-%E4%BD%BF%E7%94%A8homebrew%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85/"},{"title":"用Ant Design Pro搭建博客后台管理系统","text":"很简单，步骤分为两步：step1：打开它的官网文档step2：…稍等，有个error （暴风晕眩！！！我的错误代码没保存上 不过没关系啦，我们的错误不一样~） 在淘宝镜像create-umi有一个FAQ，他说试一下手动安装 create-umi，好的。 12$ npm install create-umi -g$ create-umi 然后选择，选择，回车，加载，ok。 12345678910111213141516PS E:\\MyProjects\\personal-site-admin&gt; create-umi? Select the boilerplate type ant-design-pro? �慄 Be the first to experience the new umi@3 ? Pro ? �邏 Which language do you want to use? TypeScript? � Do you need all the blocks or a simple scaffold? comple&gt; � complete mode can only use the version of antdCloning into &apos;E:\\MyProjects\\personal-site-admin&apos;...remote: Enumerating objects: 573, done.remote: Counting objects: 100% (573/573), done.remote: Compressing objects: 100% (484/484), done.Receiving objects: 95% (545/573), 444.00 KiB | 278.00 KiB/seused 0Receiving objects: 100% (573/573), 463.55 KiB | 285.00 KiB/s, done.Resolving deltas: 100% (94/94), done.&gt; � clone succe&gt; Clean up...✨ File Generate Done 但启动的路上总是问题重重！ 123456789&apos;umi&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! ant-design-pro@4.3.0 start: `umi dev`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the ant-design-pro@4.3.0 start script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above. 他说，”这个问题和我，npm，毛关系没有，看日志吧你。” 好的~ 12$ yarn global add umi$ umi -v 你猜怎么着，还是报错哦！ 123456umi : 无法将“umi”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ umi -v+ ~~~ + CategoryInfo : ObjectNotFound: (umi:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException 不急，配置一下全局！ 1$ yarn global bin 输入以上命令后，得到yarn的地址，然后配置。 再次看看umi能用不。嘿嘿，不可以。 我手动找找这个命令在哪儿，这不是吗？一毛一样！ 算了，还是找npm帮帮忙吧。 1$ npm install umi -g emm······umi又可以了。还是有很多包提示没安装上。删除node_modules,再来一次！ no no no,失败。用下面这个再试 1$ yarn 可以了。 1$ yarn start 启动了。","link":"/2020-12-%E5%8D%9A%E5%AE%A2-%E7%94%A8ant-design-pro%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"title":"学会在react项目上搞样式","text":"打开Ant Design 实战教程（beta 版），咱们先从文档来123456import myStyles from &apos;./styles.css&apos;;export default () =&gt; { return ( &lt;div className={myStyles.hello}&gt;Hello World&lt;/div&gt; );}; 12345.hello { font-size: 32px; font-weight: bold; color: #30b767; /* 绿色 */} 很简单嘛，对吧！那咱们看看注意事项 首先，最好文件放置位置如下：12345.└── src └── pages ├── index.jsx └── styles.css 其次，注意css文件的写法： 注意： 对于 css 文件， 不要在值上使用引号； .号要紧跟 hello，定义一个 class 选择器。 123456/* 错误！1. 引号是无效的；2. hello 前面的点漏掉了 */hello { font-size: &apos;32px&apos;; font-weight: &apos;bold&apos;; color: &quot;#30b767&quot;;} 这个优秀的文档又带咱们熟悉一下CSS modules，请看下图： 我们看到它实际的 class 是 style__hello__&lt;hash数值&gt;，并非在源文件中声明的 hello。这就是 CSS modules 起了作用。这个 hash 值是全局唯一的，比如通过文件路径来获得，这样 class 名称就做到了全局唯一。通过全局唯一的 CSS 命名，我们变相地获得了局部作用域的 CSS（scoped CSS）。如果一个 CSS 文件仅仅是作用在某个局部的话，我们称这样一个 CSS 文件为 CSS module。 好家伙，文档作者说，光css不够味啊，得less来撺掇撺掇 Less 介绍 Less 是一个 CSS 的超集，Less 允许我们定义变量，使用嵌套式声明，定义函数等。严格说 Less 包含两部分：1. Less 的语法。2. Less 预处理器（Less preprocessor）。浏览器终究只认识 CSS，所以 Less 文件需要经过 Less 预处理器编译成为 CSS。 在工具的支持下，一个 Less 文件首先会经过 CSS modules 的编译，把类名全局唯一化，然后才被 Less preprocessor 编译成为 CSS 文件。正因此，Less 文件可以和 CSS modules 无缝联合使用。 咱们跟着作者的例子走：第一，我们建立一个新页面 css-modules-with-less，并且使用 less 文件作为样式文件。 12345678.└── src └── pages ├── css-modules-with-less │ ├── index.jsx │ └── styles.less ├── index.jsx └── styles.css 第二，我们定义 less 文件，故意添加一些非 css 语法，比如嵌套、变量定义。 1234567891011@grey-color: rgba(0, 0, 0, .25);.hello { font-size: 32px; font-weight: bold; color: #30b767; .deleted { text-decoration: line-through; background-color: @grey-color; }} 第三，我们创建页面，并使用这份样式。 12345678import styles from &apos;./styles.less&apos;;export default () =&gt; { return ( &lt;div className={styles.hello}&gt; &lt;span className={styles.deleted}&gt;Hello World&lt;/span&gt; &lt;/div&gt; );}; 重点来了，想要大战阔斧操刀你要的东西，那还不得在全局样式下下功夫呀来，咱们呀，继续跟着作者的小例子走：先来 Button 组件的 .ant-btn 类下手试试， 比如我们想要覆盖掉 .ant-btn 中声明的 border-radius 属性，来绘制圆角按钮。直观的想法是： 123456789&lt;!-- 在 css/less 文件中定义覆盖 --&gt;.override-ant-btn .ant-btn { border-radius: 16px;}&lt;!-- 在 html 中使用对应的 class 名称 --&gt;&lt;span className={styles[&apos;override-ant-btn&apos;]}&gt; &lt;Button&gt;加入圆角的按钮&lt;/Button&gt;&lt;/span&gt; 你猜怎么着？ 嗨！没成功，为嘛呢？请看： 由于 CSS modules 的使用， ant-btn 被改名了！你看这好东西，前面觉得香吧！但是呢，成也它，败也它。诶诶诶，别走啊，没说完呢？你咋想嫩美呢，啥简单方法你都想干，编译机器有说过一句抱怨的话吗，你还不乐意了害！我问了问它，它回话了，说：用俺的 global 语法 ！方法都跟你想好了，声明一个 class 名称不可被改写。语法你看下面：123:global(.ant-btn) { // ...} 这不，小例子又来了嘛：第一，我们建立一个新页面 css-modules-with-antd。 1234567891011.└── src └── pages ├── css-modules-with-antd │ ├── index.jsx │ └── styles.less ├── css-modules-with-less │ ├── index.jsx │ └── styles.less ├── index.jsx └── styles.css 第二，我们建立页面文件，包含两个 antd Button，其中一个需要被样式覆盖，一个不需要。 1234567891011121314151617import styles from &apos;./styles.less&apos;;import { Button } from &apos;antd&apos;;export default () =&gt; { return ( &lt;div&gt; &lt;p&gt; &lt;span className={styles[&apos;override-ant-btn&apos;]}&gt; &lt;Button&gt;圆角样式按妞&lt;/Button&gt; &lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;Button&gt;antd 原始按钮&lt;/Button&gt; &lt;/p&gt; &lt;/div&gt; );}; 第三，我们建立样式文件覆盖 antd 原生样式，用 global 来声明不修改 class 名。 12345.override-ant-btn { :global(.ant-btn) { border-radius: 16px; }} 但还是有一句话得说，global 不应该被滥用，要是咱们都用，来来来，笔都给他，让他自己写框架好了！然后再来一个小小的建议：若想在某个文件中覆盖 antd 样式，请加上一个类似 .override-ant-btn 的类包裹住 global 修饰的名称，以避免全局样式声明分散在项目各处。 听清楚作者的话了没！好了，真正的重中之重来了不是前面有个人说，领导事多，啥都要改嘛！不怕，这次咱们去另一个好地方搞一下子，全部大变样！咱们呀，直接更换 antd 主题！前面章节我们讲过如何覆盖某个页面中 antd 的样式，有时候我们想要「批量修改」 antd 的样式，这就需要利用 less 提供的一个能力：modifyVars。简单地讲，antd 在使用 less 定义样式时，使用了大量的变量声明。这些变量的定义在编译期是可以被工具识别并修改的。 如果使用的是 umi ，这个过程相当简单，只需要简单地修改配置文件即可。 第一，找到 umi 的配置文件，如果不存在则创建一个。注意配置文件放置的位置。我们这里使用 .umirc.js 。 12345678910111213141516├── .gitignore├── .umirc.js└── src ├── global.less └── pages ├── .umi │ ├── router.js │ └── umi.js ├── css-modules-with-antd │ ├── index.jsx │ └── styles.less ├── css-modules-with-less │ ├── index.jsx │ └── styles.less ├── index.jsx └── styles.css 第二，把之前创建的 css-modules-with-antd 页面中的 Button 加上 type=“primary” 定义。当 type 值为 “primary” 时，Button 应该显示为蓝色按钮。 12345678910111213&lt;div&gt; &lt;p&gt; &lt;span className={styles[&apos;override-ant-btn&apos;]}&gt; &lt;Button type=&quot;primary&quot;&gt;圆角样式按妞&lt;/Button&gt; &lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;Button type=&quot;primary&quot;&gt;antd 原始按钮&lt;/Button&gt; &lt;/p&gt;&lt;/div&gt; 第三，配置 umi 主题（实质是 modifyVars 机制）。如果是创建新文件，则写入： 12345export default { theme: { &quot;@primary-color&quot;: &quot;#30b767&quot;, }} 如果是已存在配置文件，则把 theme 这一段嵌入到 export default 内部。 123456789export default { // 若已有配置 outputPath: &quot;./build&quot;, // 加入 theme 定义 theme: { &quot;@primary-color&quot;: &quot;#30b767&quot;, // 绿色 }} 在 antd Button 定义时，颜色并不是写死的，而是使用了 Less 变量。我们看到修改变量后，按钮的颜色变为了绿色。 这儿看到了吗？好地方，点一哈子，莫傻傻看到起。好东西都在里面，想搞哪个，里面随意挑。有人还是不满意哈，懒得找，懒得一个一个改，全写配置里不优雅。作者都帮你想好啦！咱们搞全局样式！专人专项！这就是更改全局样式如果使用 umi 的话，有一个专门的文件 global.less 来让我们书写全局样式。这个文件并不会被 CSS modules 处理。 123456789101112.└── src ├── global.less └── pages ├── css-modules-with-antd │ ├── index.jsx │ └── styles.less ├── css-modules-with-less │ ├── index.jsx │ └── styles.less ├── index.jsx └── styles.css 一个用途是全局性地定义 HTML 标签的样式，比如写入： 123p { margin: 0;} 如果此时去往 css-modules-with-antd 会发现上下两个按钮贴在一起了。 原因是在大多数浏览器中，默认 p 元素是有 1em 高度的 margin-bottom。而我们的定义覆盖了默认的样式。 另外一个用途是全局性地覆盖第三方库的样式，比如 antd 中的样式 。 我们全局覆盖 ant-btn 的样式，增加下面的定义： 123.ant-btn { box-shadow: 0 3px 7px rgba(0, 0, 0, .5);} 可以看到我们成功地添加了按钮阴影 咱们可以去Ant Design 实战教程（beta 版）里看一下具体修改内容。现在咱们换一篇官方文档看看！嘻嘻参考： Ant Design 实战教程（beta 版） Ant Design Pro文档","link":"/2021-1-%E5%89%8D%E7%AB%AF/React-%E5%AD%A6%E4%BC%9A%E5%9C%A8react%E9%A1%B9%E7%9B%AE%E4%B8%8A%E6%90%9E%E6%A0%B7%E5%BC%8F/"},{"title":"使用Ant Design Pro遇到的困难和解决路程","text":"问题1：hideInTable、hideInForm这两个参数未起效。 解决1：改为hideInTable: true,hideInForm: true。 找到Ant Design Pro的文档（终于找到了），切记解决问题仔细读源码和认真思考文档的含义！ 他说的是不展示！那么应该打true！！！ 可能被search误导了，不过文档需要完善，这两个参数后面应该默认false。 问题2：创建时间的valueType为 ‘dateRange’，但是表格展示应该是dateTime。 解决2：暂未找到解决办法，临时写个参数。用时超过二十分钟，现在的我基础不够，乱琢磨乱百度也是浪费时间 问题3：对新建表单做样式修改。同一组数据，在查询表单、新建表单、表格等展示。新建表单这里用的ProTable组件，type为form即可展示。 解决3:在form属性链接antd的样式 问题4:一个警告，需要key值 解决4:rowKey不能写死了。看到一篇博客，Ant Design Table组件报错，提示table should have a unique ‘key’ prop的解决办法","link":"/2021-1-%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-%E4%BD%BF%E7%94%A8ant-design-pro%E9%81%87%E5%88%B0%E7%9A%84%E5%9B%B0%E9%9A%BE%E5%92%8C%E8%A7%A3%E5%86%B3%E8%B7%AF%E7%A8%8B/"},{"title":"切换node版本","text":"首先，问题抛出来：https://github.com/nuxt/nuxt.js/issues/2927在这个问答里面找到了是node版本的原因，于是需要切换node试一试～ 第一步：安装node版本管理模块n1sudo npm install n -g 第二步：安装需要的版本1sudo n 版本号 第三步：切换版本1n 版本号 此外，还有几个命令也许以后用得上 安装稳定版 1sudo n stable 安装最新版 1sudo n latest 看看还安了啥版本 1n 删除版本 1sudo n rm 版本号 顺便，要记得看看npm版本和node版本能不能匹配 node.js以往的版本第一步：查看node版本和npm版本12$ node -v$ npm -v 第二步：更新到指定版本1npm -g install npm@版本号 或者，更新最新版本 1npm install -g npm 参考： Node快速切换版本、版本回退(降级)、版本更新(升级) npm 如何提升最新版本","link":"/2021-3-%E5%89%8D%E7%AB%AF/node-%E5%88%87%E6%8D%A2node%E7%89%88%E6%9C%AC/"},{"title":"深入Vue3+TypeScript技术栈:Vue3初体验（学习笔记一）","text":"首先从老师的思路大概了解到此次课程的走向：![一.邂逅体验Vue3](https://zoujianhua.oss-cn-chengdu.aliyuncs.com/liuqianjun/一. 邂逅体验Vue3.png) 老师宣讲资料中的五点内容： 1.Vue、React、Angular三大框架对比2.Vue3带来哪些新的特性3.Vue3的安装和开发体验4.Vue3的createApp函数解析5.Vue3源码的阅读方式 由此学前给自己提出的问题： 了解createApp函数解析 学会阅读vue3源码的方法 把老师的pdf用思维导图方式画出来 自己敲完整一遍老师的代码 学习中我给自己留下的问题： 写出mvc和mvvm的区别 template属性 自己录一个操作视频配上录音 sourcemap的用法 课后老师留的问题： methods属性里的方法为什么不能使用箭头函数(官方文档有给出解释)? 不使用箭头函数的情況下,this到底指向的是什么?(可以作为一道面试题) 针对课件，做了思维导图： MVC和MVVM的区别 MVC 是 Model View Controller 的缩写 Model：模型层，是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。 View：视图层，用户界面渲染逻辑，通常视图是依据模型数据创建的。 Controller：控制器，数据模型和视图之间通信的桥梁，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVC的思想：Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View。 MVC的特点：实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。就是将模型和视图之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。 MVC的优点： 耦合度低，视图层和业务层分离 重用度高 生命周期成本低 可维护性高 部署快 MVC的缺点： 不适合小型项目的开发 视图与控制器间的过于紧密的连接，视图与控制器是相互分离，但却是联系紧密的部件，妨碍了他们的独立重用 降低了视图对模型数据的访问，依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能 MVC的应用：主要用于中大型项目的分层开发。 MVC的例子： 举一个例子，页面有一个 id 为 container 的 span，点击按钮会让其内容加 1 view: 1234&lt;div&gt; &lt;span id=&quot;container&quot;&gt;0&lt;/span&gt; &lt;button id=&quot;btn&quot;&gt;+&lt;/button&gt;&lt;/div&gt; controller： 12345678const button = document.getElementById(&apos;btn&apos;);// 响应视图指令button.addEventListener(&apos;click&apos;, () =&gt; { const container = document.getElementById(&apos;container&apos;); // 调用模型 add(container);}, false); model： 12345678function add (node) { // 业务逻辑处理 const currentValue = parseInt(node.innerText); const newValue = currentValue + 1; // 更新视图 node.innerText = newValue;} MVVM是Model-View-ViewModel的简写，即模型-视图-视图模型 Modal：模型，指的是后端传递的数据。 View：视图，指的是所看到的页面。 ViewModel：视图模型，mvvm模式的核心，它是连接view和model的桥梁。主要用来处理业务逻辑。 模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。 视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。 MVVM的特点： 在MVVM的框架下，视图和模型是不能直接通信的，它们通过ViewModal来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。 MVVM的优点： MVVM模式的主要目的是分离视图（View）和模型（Model） 低耦合，视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发，开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。 可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。 双向数据绑定，它实现了View和Model的自动同步，当Model的属性改变时，不需要手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。 MVVM适用场景： 适合数据驱动的场景，数据操作比较多的场景 vue的选项式API中@的methods属性的箭头函数里，this的指向问题 在Vue所有的生命周期钩子方法（如beforeCreate，created，beforeMount，mounted，beforeUpdate， updated，beforeDestroy以及destroyed）里使用this，this指向调用它的Vue实例 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue@2.5.9/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;div id=&quot;app&quot; style=&quot;width: 100%;height: auto;font-size:20px;&quot;&gt; 1&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.createApp({ template:&quot;#app&quot;, data:{ sList: [1,2,3], sResultList: [] }, methods:{ group:function(){ //ES5的普通函数写法，这里的this指向app,指向vue实例 this....... }, group1:()=&gt;{ //ES6的箭头函数写法，箭头函数没有自己的this,它的this事继承来的，指向在定义它时所处的宿主对象，在这里this指向window。 this....... }, group2:function(){ //这里的this同group中的this一样，指向vue实例 this.sList.forEach(function(obj){ //匿名函数中的this //在匿名函数中，这里的this不指向vue实例，这里的this指向window，在严格模式下，this指向undefined ，要使用this，可以直接用app（即vue实例）。 app.sResultList.push(obj) // this.sResultList.push(obj) }) }, group3:function(){ //这里的this同group中的this一样，指向vue实例 this.sList.forEach((obj)=&gt;{ //既是匿名函数又是箭头函数中的this //匿名函数没有自己的this，它的this继承来的，也可以说这里的this指向跟上一级的this指向相同，即vue实例 this.sResultList.push(obj) }) } }, }).mount(&apos;#app&apos;) &lt;/script&gt;&lt;/html&gt; 来自官方文档的解释： 用sourcemap调试源码123&quot;scripts&quot;: { &quot;dev&quot;: &quot;node scripts/dev.js --sourcemap&quot;} 1$ yarn dev 参考文档： vue源码分析系列:用sourcemap调试源码 vue中或箭头函数中，this的指向问题 面试题：mvc和mvvm的区别和应用场景","link":"/2021-5-%E5%89%8D%E7%AB%AF/Vue-%E6%B7%B1%E5%85%A5vue3-typescript%E6%8A%80%E6%9C%AF%E6%A0%88-vue3%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%89/"}],"tags":[{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"字符串字面量","slug":"字符串字面量","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"homebrew","slug":"homebrew","link":"/tags/homebrew/"},{"name":"antd","slug":"antd","link":"/tags/antd/"},{"name":"CSS modules","slug":"CSS-modules","link":"/tags/CSS-modules/"},{"name":"切换版本","slug":"切换版本","link":"/tags/%E5%88%87%E6%8D%A2%E7%89%88%E6%9C%AC/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"mac","slug":"mac","link":"/categories/mac/"},{"name":"React","slug":"前端/React","link":"/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"TypeScript","slug":"前端/TypeScript","link":"/categories/%E5%89%8D%E7%AB%AF/TypeScript/"},{"name":"工作记录","slug":"工作记录","link":"/categories/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"},{"name":"node","slug":"前端/node","link":"/categories/%E5%89%8D%E7%AB%AF/node/"},{"name":"Vue","slug":"前端/Vue","link":"/categories/%E5%89%8D%E7%AB%AF/Vue/"}]}